/*
 * Copyright (C) 2021. GPL
 *
 * Written by Sadovskiy B. S.
 *
 * Права на программу (С) 2021. GPL
 *
 * Написана Садовским Б. С.
 *
 * Пример привидения типа reinterpret_cast
 * Подробнее тут: https://ru.stackoverflow.com/questions/716240/В-чём-смысл-существования-reinterpret-cast
 *
 * reinterpret_cast используется не только для преобразования указателей одного
 * типа в другой. Существует несколько разных преобразований.
 * cppreference.com выделяет 11 вариантов преобразований:
 * - В свой собственный тип
 * - Указателя в интегральный тип
 * - Интегрального типа в указатель
 * - Типа std::nullptr_t в интегральный тип
 * - Указателя одного типа в указатель другого типа
 * - lvalue одного типа в ссылку на другой тип
 * - Указателя на функцию одного типа в указатель на функцию другого типа
 * - Указателя на функцию в void*
 * - Нулевого указателя любого типа в указатель любого другого типа
 * - rvalue указатель одного типа на функцию-член в указатель другого
 *   типа на функцию-член
 * - rvalue указатель члена-данных одного типа в указатель ну другой
 *   член-данных другого типа
 *
 * Type aliasing-правила затрагивают только пункты 5 и 6 и результат может
 * быть безопасно использован (т.е. без нарушения strict-aliasing)
 * в следующих случаях:
 * - Результирующий тип есть динамический тип исходного объекта
 * - Результирующий тип и динамический тип указывают на одинаковый тип T
 * - Результирующий тип есть знаковый или беззнаковый вариант
 *   типа исходного объекта
 * - Результирующий тип есть агрегатный тип или union,
 *   в котором содержится элемент или нестатический член данных,
 *   используемый в качестве исходного объекта. Т.е. можно получить
 *   указатель на структуру по указателю на её член.
 * - Результирующий тип есть базовый класс динамического типа
 *   исходного объекта и этот тип является standard-layout классом
 *   и не содержит нестатических членов-данных, и результирующий
 *   тип - первый базовый класс.
 * - Результирующий тип есть указатель на char, unsigned char или std::byte.
 * Некоторые реализации ослабляют эти правила в качестве нестандартных расширений языка.
 *
 */

#include <iostream>

using namespace std;

int main()
{
    int n = 10;
    double m = 0;
    char *c = 0;


    // Неявное приведение типа от int к double
    m = n;

    // Явное в С-стиле (небезопасно, неопределённый результат)
    m = (double)n; // или в стиле C++ m = double (n);

    cout.fill('-');
    cout.width(20);
    cout << '\n';
    cout << "n: " << n << "\n"
         << "m: " << m << "\n"
         << "c: " << "Impossible to show zero." << endl; // Нельзя вывести 0

    n = 49; // Поменяем значение на '1' по таблице ASCII

//    m = reinterpret_cast<double>(n); // Ошибка, так как reinterpret_cast
                                       // не может приводить напрямую.
                                       // Работает только через указатель
                                       // или для целых чисел

    // Не работает, так как char слишком мал для хранения указателя
//    char ch = (char)&n;

    // Пример использования.
    c = reinterpret_cast<char *>(&n);

    // Приведение типа с помощью reinterpert_cast всё равно опасная операция, но
    // всё равно не всё что вздумается. Например, нельзя привести указатель на
    // функцию к указателю на переменную или привести указатель к целому.

    cout.fill('-');
    cout.width(20);
    cout << '\n';
    cout << "n: " << n << "\n"
         << "m: " << m << "\n"
         << "c: " << *c << endl;

    return 0;
}
